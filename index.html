<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width,initial-scale=1" />
		<title>Word Guess</title>
		<meta name="description" content="A fun word guessing game with multiple difficulty levels" />
		<meta name="theme-color" content="#1a1a1a" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="apple-mobile-web-app-title" content="Word Guess" />
		<link rel="apple-touch-icon" sizes="192x192" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><rect width='192' height='192' fill='%23333'/><text x='96' y='120' font-family='Arial,sans-serif' font-size='60' fill='white' text-anchor='middle'>W</text></svg>" />
		<link rel="manifest" href="manifest.json" />
		<link
			rel="stylesheet"
			href="style.css" />
	</head>
	<body>
		<!-- Win Modal -->
		<div
			id="winModal"
			class="modal"
			role="dialog"
			aria-modal="true"
			aria-labelledby="winTitle"
			hidden>
			<div
				class="modal__backdrop"
				data-close></div>
			<div
				class="modal__panel"
				role="document">
				<h2
					id="winTitle"
					class="modal__title">
					üéâ Congratulations! You got it!
				</h2>
				<p
					class="modal__subtitle"
					id="winSub"></p>

				<div class="modal__stats">
					<div class="stat">
						<div
							class="num"
							id="mTotal">
							0
						</div>
						<div class="lbl">Played</div>
					</div>
					<div class="stat">
						<div
							class="num"
							id="mWinRate">
							0%
						</div>
						<div class="lbl">Win Rate</div>
					</div>
					<div class="stat">
						<div
							class="num"
							id="mCurrent">
							0
						</div>
						<div class="lbl">Current Streak</div>
					</div>
					<div class="stat">
						<div
							class="num"
							id="mMax">
							0
						</div>
						<div class="lbl">Max Streak</div>
					</div>
				</div>

				<div class="modal__actions">
					<button
						class="btn btn-primary"
						id="playAgainBtn">
						Play Again
					</button>
					<button
						class="btn"
						id="modalShareBtn">
						Share
					</button>
					<button
						class="btn"
						id="modalSettingsBtn">
						Settings
					</button>
					<button
						class="btn"
						id="closeModalBtn"
						aria-label="Close">
						Close
					</button>
				</div>
			</div>
		</div>
		<canvas
			id="fx"
			class="fx"
			aria-hidden="true"></canvas>

		<div class="wrap">
			<h1 class="title">WORD GUESS</h1>
			<header class="controls">
				<div
					class="btn"
					id="new">
					New
				</div>
				<div
					class="btn"
					id="reveal">
					Reveal
				</div>
				<div
					class="btn"
					id="copy">
					Share
				</div>
				<details
					id="settings"
					class="settings">
					<summary
						aria-label="Settings"
						title="Settings">
						‚öôÔ∏è
					</summary>
					<div class="settings-panel">
						<div
							class="controls"
							role="group"
							aria-label="Length & Mode">
							<span class="config">Word Length:</span>
							<button
								class="btn diffL"
								data-len="4"
								aria-pressed="false">
								4
							</button>
							<button
								class="btn diffL"
								data-len="5"
								aria-pressed="true">
								5
							</button>
							<button
								class="btn diffL"
								data-len="6"
								aria-pressed="false">
								6
							</button>
							<button
								class="btn diffL"
								data-len="7"
								aria-pressed="false">
								7
							</button>
							<button
								class="btn diffL"
								data-len="8"
								aria-pressed="false">
								8
							</button>
							<span
								class="btn"
								id="hard"
								role="switch"
								aria-checked="false"
								title="Strict mode: must use revealed hints"
								>Strict: Off</span
							>
						</div>

						<div
							class="controls"
							role="group"
							aria-label="Attempts Difficulty">
							<span class="config">Difficulty:</span>
							<button
								class="btn diffA"
								data-diff="base"
								aria-pressed="true">
								Base
							</button>
							<button
								class="btn diffA"
								data-diff="hard"
								aria-pressed="false">
								Hard
							</button>
							<button
								class="btn diffA"
								data-diff="expert"
								aria-pressed="false">
								Expert
							</button>
							<button
								class="btn diffA"
								data-diff="impossible"
								aria-pressed="false">
								Impossible
							</button>
						</div>

						<div class="controls">
							<div
								class="btn"
								id="history">
								History
							</div>
							<div
								class="btn"
								id="resetSeen">
								Reset Seen
							</div>
							<div
								class="btn"
								id="exportBtn">
								Export
							</div>
							<label
								class="btn"
								for="importFile"
								>Import</label
							>
							<input
								id="importFile"
								type="file"
								accept="application/json"
								hidden />
							<div
								class="btn btn-hidden"
								id="installBtn">
								üì± Add to Home Screen
							</div>
						</div>
					</div>
				</details>
			</header>

			<main
				id="main"
				class="main">
				<div
					id="board"
					class="board"
					aria-live="polite"></div>
				<div
					class="status"
					id="status"></div>
				<details
					class="stats"
					id="statsPanel">
					<summary>Stats</summary>
					<div class="stats-grid">
						<div class="stat">
							<div
								class="num"
								id="stTotal">
								0
							</div>
							<div class="lbl">Played</div>
						</div>
						<div class="stat">
							<div
								class="num"
								id="stWinRate">
								0%
							</div>
							<div class="lbl">Win Rate</div>
						</div>
						<div class="stat">
							<div
								class="num"
								id="stCurrent">
								0
							</div>
							<div class="lbl">Current Streak</div>
						</div>
						<div class="stat">
							<div
								class="num"
								id="stMax">
								0
							</div>
							<div class="lbl">Max Streak</div>
						</div>
						<div class="stat">
							<div
								class="num"
								id="stL5">
								0%
							</div>
							<div class="lbl">5-letter WR</div>
						</div>
						<div class="stat">
							<div
								class="num"
								id="stL6">
								0%
							</div>
							<div class="lbl">6-letter WR</div>
						</div>
					</div>
				</details>
			</main>
		</div>

		<script>
			/** === CONFIG === */
			const WORKER_BASE = "wordguess-sync.super-glade-bb1d.workers.dev";
			const DAILY_CAP_ENABLED = false; // placeholder
			const DAILY_CAP_LIMIT = 5; // Not used unless the above is true

			// Attempts per word length & difficulty
			const ATTEMPTS = {
				4: { base: 6, hard: 5, expert: 4, impossible: 3 },
				5: { base: 6, hard: 5, expert: 4, impossible: 3 },
				6: { base: 7, hard: 6, expert: 5, impossible: 4 },
				7: { base: 8, hard: 7, expert: 6, impossible: 5 },
				8: { base: 8, hard: 6, expert: 5, impossible: 4 },
			};

			/** === State === */
			let wordLen = 5;
			let difficulty = "base";
			let maxRows = ATTEMPTS[wordLen][difficulty];
			let target = "";
			let row = 0,
				col = 0,
				grid = [],
				hardMode = false,
				kbState = {};
			let WORDS = {}; // loaded lists per length
			let VALID = {}; // same as WORDS by default

			const board = document.getElementById("board");
			const status = document.getElementById("status");

			/** === Identity === */
			const userId = (() => {
				const k = "wg-user-id";
				let v = localStorage.getItem(k);
				if (!v) {
					v = crypto.getRandomValues(new Uint32Array(4)).join("-");
					localStorage.setItem(k, v);
				}
				return v;
			})();

			/** === Async loader for word lists (4‚Äì8) === */
			const wordCache = {};
			async function loadWords(len) {
				if (wordCache[len]) return wordCache[len];

				// Try these in order; first one that loads wins
				const candidates = [`words/words-${len}.json`, `words/words-clean-${len}.json`, `words/words-base-${len}.json`];

				let arr = [];
				for (const url of candidates) {
					try {
						const res = await fetch(url, { cache: "no-cache" });
						if (res.ok) {
							arr = await res.json();
							console.log(`[words] loaded ${url} (${arr.length})`);
							break;
						}
					} catch (_) {}
				}

				if (!arr.length) {
					setStatus(`Couldn't load any word list for ${len}. Place one in ./words/`);
					return [];
				}

				// normalize + sanity log
				const list = arr.map((w) => String(w).toLowerCase());
				wordCache[len] = list;
				console.log(`[words] sample[${len}]:`, list.slice(0, 8));
				return list;
			}

			/** === Seen/History (local) === */
			function loadSeen(len) {
				try {
					return JSON.parse(localStorage.getItem(`wg-seen-${len}`)) || { seen: [], max: 500 };
				} catch {
					return { seen: [], max: 500 };
				}
			}
			function saveSeen(len, obj) {
				localStorage.setItem(`wg-seen-${len}`, JSON.stringify(obj));
			}
			function clearSeen(len) {
				const cur = loadSeen(len);
				saveSeen(len, { seen: [], max: cur.max });
			}
			function getSeenCount(len) {
				return loadSeen(len).seen.length;
			}
			function loadHistory() {
				try {
					return JSON.parse(localStorage.getItem("wg-history")) || [];
				} catch {
					return [];
				}
			}
			function saveHistory(h) {
				localStorage.setItem("wg-history", JSON.stringify(h));
			}

			/** === Sync (KV Worker) === */
			async function serverGet() {
				const r = await fetch(`${WORKER_BASE}/sync`, { headers: { "X-WordGuess-User": userId } });
				if (!r.ok) throw new Error("sync GET failed");
				return r.json();
			}
			async function serverPost(payload) {
				const r = await fetch(`${WORKER_BASE}/sync`, {
					method: "POST",
					headers: { "content-type": "application/json", "X-WordGuess-User": userId },
					body: JSON.stringify(payload),
				});
				if (!r.ok) throw new Error("sync POST failed");
				return r.json();
			}
			async function syncPull() {
				if (!WORKER_BASE || !WORKER_BASE.startsWith("http")) {
					console.log("[sync] No worker configured, skipping pull");
					return;
				}
				try {
					const remote = await serverGet();
					for (const len of [4, 5, 6, 7, 8]) {
						const local = loadSeen(len);
						const merged = [...(local.seen || []), ...(remote.seenByLen?.[len] || [])];
						const uniq = Array.from(new Set(merged)).slice(-500);
						saveSeen(len, { seen: uniq, max: local.max || 500 });
					}
					// history
					const hist = [...loadHistory(), ...(remote.history || [])].sort((a, b) => (a.ts || 0) - (b.ts || 0));
					const keys = new Set(),
						uniq = [];
					for (const h of hist) {
						const k = `${h.word}|${h.len}|${h.ts}`;
						if (!keys.has(k)) {
							keys.add(k);
							uniq.push(h);
						}
					}
					saveHistory(uniq.slice(-5000));
					updateStats(remote.stats || computeStats(uniq));
					setStatus("Synced.");
				} catch (error) {
					console.warn("[sync] Pull failed:", error);
					setStatus("Sync failed (pull). Playing offline.");
				}
			}
			async function syncPush() {
				if (!WORKER_BASE || !WORKER_BASE.startsWith("http")) {
					console.log("[sync] No worker configured, skipping push");
					return;
				}
				try {
					const seenByLen = {};
					for (const len of [4, 5, 6, 7, 8]) seenByLen[len] = loadSeen(len).seen;
					const server = await serverPost({ seenByLen, history: loadHistory() });
					updateStats(server.stats || {});
				} catch (error) {
					console.warn("[sync] Push failed:", error);
					// Don't show error message for push failures to avoid interrupting gameplay
				}
			}

			/** === Stats === */
			function computeStats(history) {
				if (!history.length) return { total: 0, wins: 0, winRate: 0, currentStreak: 0, maxStreak: 0, perLen: {} };
				let cur = 0,
					max = 0,
					total = history.length,
					wins = 0;
				for (const h of history) {
					if (h.won) {
						wins++;
						cur++;
						max = Math.max(max, cur);
					} else cur = 0;
				}
				const perLen = {};
				for (const len of [4, 5, 6, 7, 8]) {
					const items = history.filter((h) => h.len === len);
					const w = items.filter((h) => h.won).length;
					perLen[len] = { total: items.length, wins: w, winRate: items.length ? Math.round((100 * w) / items.length) : 0 };
				}
				return { total, wins, winRate: Math.round((100 * wins) / total), currentStreak: cur, maxStreak: max, perLen };
			}
			function updateStats(stats) {
				const hist = loadHistory();
				const s = stats && stats.total !== undefined ? stats : computeStats(hist);
				document.getElementById("stTotal").textContent = s.total || 0;
				document.getElementById("stWinRate").textContent = (s.winRate || 0) + "%";
				document.getElementById("stCurrent").textContent = s.currentStreak || 0;
				document.getElementById("stMax").textContent = s.maxStreak || 0;
				document.getElementById("stL5").textContent = (s.perLen?.[5]?.winRate || 0) + "%";
				document.getElementById("stL6").textContent = (s.perLen?.[6]?.winRate || 0) + "%";
			}

			/** === Daily cap placeholder === */
			function checkDailyCap() {
				if (!DAILY_CAP_ENABLED) return true;
				const k = "wg-dcap",
					today = new Date().toISOString().slice(0, 10);
				const raw = JSON.parse(localStorage.getItem(k) || "{}");
				if (raw.day !== today) {
					raw.day = today;
					raw.count = 0;
				}
				if (raw.count >= DAILY_CAP_LIMIT) {
					setStatus(`Daily cap reached (${DAILY_CAP_LIMIT}).`);
					return false;
				}
				raw.count++;
				localStorage.setItem(k, JSON.stringify(raw));
				return true;
			}

			/** === Responsive layout === */
			function updateLayout() {
				const wrap = document.querySelector(".wrap");
				const header = document.querySelector("header");
				const rows = maxRows,
					cols = wordLen,
					gap = 8;
				const vw = innerWidth,
					vh = innerHeight,
					wrapRect = wrap.getBoundingClientRect();
				const headerH = header?.getBoundingClientRect().height || 0;
				const diffH = [...document.querySelectorAll(".controls")].slice(1, 3).reduce((h, el) => h + (el?.getBoundingClientRect().height || 0), 0);
				const statsPanel = document.getElementById("statsPanel");
				const statsH = (statsPanel?.open ? statsPanel.getBoundingClientRect().height : 40) || 0;
				const verticalChrome = headerH + diffH + statsH + 80;
				const availH = Math.max(180, vh - verticalChrome);
				const availW = Math.max(220, wrapRect.width - 16);
				const totalGapW = (cols - 1) * gap,
					totalGapH = (rows - 1) * gap;
				const maxTileW = Math.floor((availW - totalGapW) / cols);
				const maxTileH = Math.floor((availH - totalGapH) / rows);
				const tile = Math.max(36, Math.min(96, Math.min(maxTileW, maxTileH)));
				document.documentElement.style.setProperty("--tile", tile + "px");
				const keyW = Math.max(28, Math.min(52, Math.floor(tile * 0.65)));
				document.documentElement.style.setProperty("--key-w", keyW + "px");
			}

			/** === Board & Input === */
			function buildBoard() {
				board.innerHTML = "";
				board.style.gridTemplateRows = `repeat(${maxRows}, var(--tile))`;
				for (let r = 0; r < maxRows; r++) {
					const rowEl = document.createElement("div");
					rowEl.className = "row";
					rowEl.style.gridTemplateColumns = `repeat(${wordLen}, var(--tile))`;
					for (let c = 0; c < wordLen; c++) {
						const t = document.createElement("div");
						t.className = "tile";
						t.dataset.r = r;
						t.dataset.c = c;
						rowEl.appendChild(t);
					}
					board.appendChild(rowEl);
				}
				grid = Array.from({ length: maxRows }, () => Array(wordLen).fill(""));
				row = 0;
				col = 0;
				kbState = {};
				renderKeyboardHints();
				updateLayout();
			}
			function buildKeyboard() {
				const wrap = document.querySelector(".wrap");
				let kb = document.getElementById("keyboard");
				if (!kb) {
					kb = document.createElement("div");
					kb.id = "keyboard";
					kb.className = "keyboard";
					wrap.appendChild(kb); // ‚¨ÖÔ∏è append as LAST child
				} else if (kb.parentElement !== wrap) {
					wrap.appendChild(kb); // ensure it's last
				}

				const rows = ["QWERTYUIOP", "ASDFGHJKL", "‚ÜµZXCVBNM‚å´"];
				kb.innerHTML = "";
				rows.forEach((r) => {
					const div = document.createElement("div");
					div.className = "kb-row";
					[...r].forEach((ch) => {
						const b = document.createElement("button");
						b.className = "key";
						b.textContent = ch === "‚Üµ" ? "Enter" : ch === "‚å´" ? "Back" : ch;
						b.dataset.key = ch;
						b.onclick = () => onPress(ch);
						div.appendChild(b);
					});
					kb.appendChild(div);
				});
			}
			addEventListener("keydown", (e) => {
				if (e.key === "Enter") return onPress("‚Üµ");
				if (e.key === "Backspace") return onPress("‚å´");
				const k = e.key.toUpperCase();
				if (/^[A-Z]$/.test(k)) onPress(k);
			});
			function onPress(k) {
				if (row >= maxRows) return;
				if (k === "‚å´") {
					if (col > 0) {
						col--;
						setCell(row, col, "");
					}
					return;
				}
				if (k === "‚Üµ") {
					handleEnter();
					return;
				}
				if (/^[A-Z]$/.test(k) && col < wordLen) {
					setCell(row, col, k);
					col++;
				}
			}
			function setCell(r, c, letter) {
				grid[r][c] = (letter || "").toUpperCase();
				const t = getTile(r, c);
				t.textContent = grid[r][c];
				t.classList.toggle("filled", !!letter);
			}
			function getTile(r, c) {
				return board.children[r].children[c];
			}
			function wiggleRow(r) {
				const re = board.children[r];
				re.style.transform = "translateX(4px)";
				setTimeout(() => (re.style.transform = ""), 100);
			}
			function renderKeyboardHints() {
				document.querySelectorAll(".key").forEach((k) => {
					const ch = k.dataset.key;
					if (!/^[A-Z]$/.test(ch)) return;
					k.classList.remove("ok", "maybe", "no");
					const st = kbState[ch];
					if (st) k.classList.add(st);
				});
			}

			/** === Game logic === */
			function isValid(word) {
				const list = VALID[word.length] || [];
				return list?.includes(word.toLowerCase());
			}
			function score(guess, answer) {
				// normalize to the same case so comparisons work
				const g = [...guess.toLowerCase()];
				const a = [...answer.toLowerCase()];

				const res = Array(wordLen).fill("no");
				const used = Array(wordLen).fill(false);

				// greens
				for (let i = 0; i < wordLen; i++) {
					if (g[i] === a[i]) {
						res[i] = "ok";
						used[i] = true;
					}
				}
				// yellows
				for (let i = 0; i < wordLen; i++) {
					if (res[i] === "ok") continue;
					const idx = a.findIndex((ch, j) => !used[j] && ch === g[i]);
					if (idx > -1) {
						res[i] = "maybe";
						used[idx] = true;
					}
				}
				return res;
			}
			function updateKeyboard(guess, res) {
				for (let i = 0; i < guess.length; i++) {
					const ch = guess[i],
						st = res[i],
						prev = kbState[ch];
					if (!prev || (prev === "maybe" && st === "ok") || (prev === "no" && (st === "ok" || st === "maybe"))) kbState[ch] = st;
				}
				renderKeyboardHints();
			}
			function respectsHardMode(guess) {
				if (!hardMode || row === 0) return true;
				const prevGuess = grid[row - 1].join("");
				const prevRes = score(prevGuess, target);
				for (let i = 0; i < wordLen; i++) {
					if (prevRes[i] === "ok" && guess[i] !== prevGuess[i]) {
						setStatus(`Strict: keep ${prevGuess[i]} at ${i + 1}.`);
						return false;
					}
				}
				const needed = {};
				for (let i = 0; i < wordLen; i++) {
					if (prevRes[i] === "maybe") {
						needed[prevGuess[i]] = (needed[prevGuess[i]] || 0) + 1;
					}
				}
				for (const ch of guess) {
					if (needed[ch]) needed[ch]--;
				}
				for (const k in needed) {
					if (needed[k] > 0) {
						setStatus(`Strict: include ${k}.`);
						return false;
					}
				}
				return true;
			}
			function handleEnter() {
				if (col < wordLen) {
					wiggleRow(row);
					return setStatus("Not enough letters.");
				}
				const guess = grid[row].join("");
				if (!isValid(guess)) {
					wiggleRow(row);
					return setStatus("Not in word list.");
				}
				if (hardMode && !respectsHardMode(guess)) {
					wiggleRow(row);
					return;
				}
				const res = score(guess, target);
				paintRow(row, res);
				updateKeyboard(guess, res);
				if (guess.toLowerCase() === target.toLowerCase()) {
					const currentrow = row + 1;
					setStatus(`Nice! You got it in ${currentrow}/${maxRows}.`);
					setTimeout(() => {
						markCompleted(wordLen, target, true, currentrow, /*showModal=*/ true);
					}, 200);
					row = maxRows;
					return;
				}
				row++;
				col = 0;
				if (row === maxRows) {
					setStatus(`Answer was ${target.toUpperCase()}.`);
					// Let markCompleted open a modal for loss too
					markCompleted(wordLen, target, /*won=*/ false, maxRows, /*showModal=*/ true);
				} else {
					setStatus("");
				}
			}
			function paintRow(r, res) {
				for (let c = 0; c < wordLen; c++) {
					const t = getTile(r, c);
					t.classList.remove("filled");
					t.classList.add(res[c]);
					t.style.transform = "scale(1.05)";
					setTimeout(() => (t.style.transform = "scale(1)"), 90);
				}
			}

			/** === Word selection with no repeats === */
			async function pickTarget(len) {
				const list = await loadWords(len);
				WORDS[len] = list;
				VALID[len] = list;
				const seen = new Set(loadSeen(len).seen);
				const candidates = list.filter((w) => !seen.has(w));
				if (!candidates.length) {
					clearSeen(len);
					return list[(Math.random() * list.length) | 0];
				}
				return candidates[(Math.random() * candidates.length) | 0];
			}
			function restoreCurrent() {
				const s = localStorage.getItem(`wg-current-${wordLen}`);
				const list = wordCache[wordLen];
				return s && list?.includes(s) ? s : "";
			}

			/** === Round completion === */
			function markCompleted(len, word, won, guesses, showModal = false) {
				const data = loadSeen(len);
				if (!data.seen.includes(word)) data.seen.push(word);
				if (data.seen.length > data.max) data.seen.splice(0, data.seen.length - data.max);
				saveSeen(len, data);

				const hist = loadHistory();
				hist.push({ word, len, won, guesses, ts: Date.now() });
				if (hist.length > 5000) hist.splice(0, hist.length - 5000);
				saveHistory(hist);
				updateStats();
				syncPush();

				if (showModal) {
					openResultModal({ len, word, guesses, won });
				} else {
					// fallback behavior if you ever call without modal
					setTimeout(() => resetGame(len), 600);
				}
			}

			// ---- Modal & fireworks ----
			function openResultModal({ len, word, guesses, won }) {
				const title = document.getElementById("winTitle");
				const sub = document.getElementById("winSub");

				// Stats snapshot
				const s = computeStats(loadHistory());
				document.getElementById("mTotal").textContent = s.total || 0;
				document.getElementById("mWinRate").textContent = (s.winRate || 0) + "%";
				document.getElementById("mCurrent").textContent = s.currentStreak || 0;
				document.getElementById("mMax").textContent = s.maxStreak || 0;

				const tries = `${guesses}/${ATTEMPTS[len][difficulty]}`;

				if (won) {
					title.textContent = "Congratulations! You got it!";
					sub.textContent = `Answer: ${word.toUpperCase()}\nSolved ${len}-letter in /${ATTEMPTS[len][difficulty]} guesses.\nMode: ${difficulty}, Strict: ${hardMode ? "On" : "Off"}`;
				} else {
					title.textContent = "So close!";
					sub.textContent = `Answer was ${word.toUpperCase()}.\nOut of tries (${ATTEMPTS[len][difficulty]}).\nMode: ${difficulty}, Strict: ${hardMode ? "On" : "Off"}`;
				}

				const modal = document.getElementById("winModal");
				modal.hidden = false;
				document.body.style.overflow = "hidden";

				// focus
				document.getElementById("playAgainBtn")?.focus();

				// Fireworks only on win
				if (won) startFireworks(1800);
				else stopFireworks();
			}

			function closeWinModal() {
				const modal = document.getElementById("winModal");
				modal.hidden = true;
				document.body.style.overflow = "";
				stopFireworks();
			}

			// Simple confetti / fireworks
			let fxRAF = null,
				fxRunning = false,
				fxParts = [];
			function startFireworks(durationMs = 1500) {
				const cvs = document.getElementById("fx");
				if (!cvs) return;
				const ctx = cvs.getContext("2d");
				const DPR = Math.max(1, window.devicePixelRatio || 1);
				function resize() {
					cvs.width = innerWidth * DPR;
					cvs.height = innerHeight * DPR;
				}
				resize();
				addEventListener("resize", resize, { once: true });

				fxParts = [];
				const colors = ["#56d364", "#e3b341", "#5b8cff", "#ff6b6b", "#a78bfa", "#34d399"];

				// spawn particles from 3 bursts
				function burst() {
					const cx = Math.random() * cvs.width,
						cy = Math.random() * cvs.height * 0.4 + cvs.height * 0.1;
					for (let i = 0; i < 80; i++) {
						const angle = Math.random() * Math.PI * 2;
						const speed = Math.random() * 4 + 2;
						fxParts.push({
							x: cx,
							y: cy,
							vx: Math.cos(angle) * speed,
							vy: Math.sin(angle) * speed,
							life: 60 + ((Math.random() * 20) | 0),
							color: colors[(Math.random() * colors.length) | 0],
						});
					}
				}
				burst();
				setTimeout(burst, 300);
				setTimeout(burst, 600);

				fxRunning = true;
				const start = performance.now();
				(function tick() {
					fxRAF = requestAnimationFrame(tick);
					ctx.clearRect(0, 0, cvs.width, cvs.height);
					// gravity
					for (const p of fxParts) {
						p.x += p.vx;
						p.y += p.vy;
						p.vy += 0.08 * DPR;
						p.life--;
						ctx.fillStyle = p.color;
						ctx.globalAlpha = Math.max(0, p.life / 80);
						ctx.fillRect(p.x, p.y, 3 * DPR, 3 * DPR);
					}
					fxParts = fxParts.filter((p) => p.life > 0);
					if (performance.now() - start > durationMs && fxParts.length === 0) {
						stopFireworks();
					}
				})();
			}
			function stopFireworks() {
				if (fxRAF) cancelAnimationFrame(fxRAF);
				fxRAF = null;
				fxRunning = false;
				fxParts = [];
				const cvs = document.getElementById("fx");
				if (cvs) {
					const ctx = cvs.getContext("2d");
					ctx && ctx.clearRect(0, 0, cvs.width, cvs.height);
				}
			}

			/** === Controls === */
			document.querySelectorAll(".diffL").forEach((b) => {
				b.addEventListener("click", async () => {
					document.querySelectorAll(".diffL").forEach((x) => x.setAttribute("aria-pressed", "false"));
					b.setAttribute("aria-pressed", "true");
					await resetGame(+b.dataset.len);
				});
			});
			document.querySelectorAll(".diffA").forEach((b) => {
				b.addEventListener("click", async () => {
					document.querySelectorAll(".diffA").forEach((x) => x.setAttribute("aria-pressed", "false"));
					b.setAttribute("aria-pressed", "true");
					difficulty = b.dataset.diff;
					await resetGame(wordLen);
				});
			});
			document.getElementById("hard").addEventListener("click", (e) => {
				hardMode = !hardMode;
				e.currentTarget.setAttribute("aria-checked", String(hardMode));
				e.currentTarget.textContent = `Strict: ${hardMode ? "On" : "Off"}`;
				e.currentTarget.style.outline = hardMode ? "2px solid var(--accent)" : "none";
				setStatus(hardMode ? "Strict mode enabled." : "Strict mode disabled.");
			});
			document.getElementById("new").onclick = () => resetGame(wordLen);
			document.getElementById("reveal").onclick = () => setStatus(`Answer: ${target.toUpperCase()}`);
			document.getElementById("copy").onclick = () => {
				const emoji = renderShare();
				navigator.clipboard.writeText(emoji).then(() => setStatus("Result copied to clipboard."));
			};
			document.getElementById("history").onclick = () => {
				const total = loadHistory().length;
				const per = [4, 5, 6, 7, 8].map((n) => `${n}L:${getSeenCount(n)}`).join(" ‚Ä¢ ");
				setStatus(`Played: ${total}. Seen ‚Äî ${per}.`);
			};
			document.getElementById("resetSeen").onclick = () => {
				clearSeen(wordLen);
				setStatus(`Cleared seen for ${wordLen}-letter.`);
			};
			document.getElementById("exportBtn").onclick = async () => {
				try {
					const r = await fetch(`${WORKER_BASE}/export`, { headers: { "X-WordGuess-User": userId } });
					const blob = await r.blob();
					const a = document.createElement("a");
					a.href = URL.createObjectURL(blob);
					a.download = `wordguess-${userId}.json`;
					a.click();
					URL.revokeObjectURL(a.href);
					setStatus("Exported.");
				} catch {
					setStatus("Export failed.");
				}
			};
			document.getElementById("importFile").onchange = async (e) => {
				const f = e.target.files?.[0];
				if (!f) return;
				try {
					const data = JSON.parse(await f.text());
					if (data?.seenByLen)
						for (const len of [4, 5, 6, 7, 8]) {
							const local = loadSeen(len);
							const merged = Array.from(new Set([...(local.seen || []), ...(data.seenByLen[len] || [])]));
							saveSeen(len, { seen: merged.slice(-500), max: local.max || 500 });
						}
					if (data?.history?.length) {
						const combo = [...loadHistory(), ...data.history].sort((a, b) => a.ts - b.ts);
						const uniq = [],
							keys = new Set();
						for (const h of combo) {
							const k = `${h.word}|${h.len}|${h.ts}`;
							if (!keys.has(k)) {
								keys.add(k);
								uniq.push(h);
							}
						}
						saveHistory(uniq.slice(-5000));
					}
					await syncPush();
					setStatus("Imported & synced.");
				} catch {
					setStatus("Import failed.");
				}
			};

			/** === PWA Installation === */
			let deferredPrompt;
			const installBtn = document.getElementById("installBtn");

			// Listen for beforeinstallprompt event
			window.addEventListener("beforeinstallprompt", (e) => {
				// Prevent the mini-infobar from appearing on mobile
				e.preventDefault();
				// Stash the event so it can be triggered later
				deferredPrompt = e;
				// Show the install button
				installBtn.classList.remove("btn-hidden");
			});

			// Handle install button click
			document.getElementById("installBtn").onclick = async () => {
				if (!deferredPrompt) {
					// Fallback for iOS and other browsers
					setStatus("To install: tap Share ‚Üí Add to Home Screen");
					return;
				}
				
				// Show the install prompt
				deferredPrompt.prompt();
				// Wait for the user to respond to the prompt
				const { outcome } = await deferredPrompt.userChoice;
				
				if (outcome === "accepted") {
					setStatus("App installed! üì±");
				} else {
					setStatus("Installation cancelled.");
				}
				
				// Clear the saved prompt since it can't be used again
				deferredPrompt = null;
				installBtn.classList.add("btn-hidden");
			};

			// Handle successful installation
			window.addEventListener("appinstalled", () => {
				setStatus("Word Guess installed successfully! üéâ");
				installBtn.classList.add("btn-hidden");
				deferredPrompt = null;
			});

			/** === Share === */
			function renderShare() {
				let lines = [];
				for (let r = 0; r < row; r++) {
					const guess = grid[r].join("");
					const res = score(guess, target);
					lines.push(res.map((v) => (v === "ok" ? "üü©" : v === "maybe" ? "üü®" : "‚¨õ")).join(""));
				}
				const fail = row === maxRows && grid[row - 1]?.join("") !== target;
				const header = `WordGuess ${wordLen}/${maxRows} ${fail ? "X" : row} ‚Ä¢ ${wordLen}-letter`;
				return `${header}\n` + lines.join("\n");
			}

			/** === Status === */
			function setStatus(msg) {
				status.textContent = msg || "";
			}

			/** === Modal Helper === */
			function wireModalHandlers() {
				const modal = document.getElementById("winModal");
				modal?.addEventListener("click", (e) => {
					if (e.target.matches("[data-close]")) closeWinModal();
				});

				document.getElementById("closeModalBtn")?.addEventListener("click", closeWinModal);
				document.getElementById("playAgainBtn")?.addEventListener("click", () => {
					closeWinModal();
					resetGame(wordLen);
				});
				document.getElementById("modalSettingsBtn")?.addEventListener("click", () => {
					closeWinModal();
					document.getElementById("settings")?.setAttribute("open", "");
					window.scrollTo({ top: 0, behavior: "smooth" });
				});
				document.getElementById("modalShareBtn")?.addEventListener("click", () => {
					const emoji = renderShare();
					navigator.clipboard.writeText(emoji).then(() => setStatus("Result copied to clipboard."));
				});
			}
			wireModalHandlers();

			/** === Init / Reset === */
			async function resetGame(len = wordLen) {
				if (!checkDailyCap()) return;
				wordLen = len;
				maxRows = ATTEMPTS[wordLen][difficulty];
				target = await pickTarget(wordLen);
				buildBoard();
				buildKeyboard();
				setStatus(`New ${wordLen}-letter word ‚Ä¢ Attempts: ${maxRows}. Go!`);
				localStorage.setItem(`wg-current-${wordLen}`, target);
				updateLayout();
			}
			async function init() {
				try {
					maxRows = ATTEMPTS[wordLen][difficulty];
					const list = await loadWords(wordLen);
					if (!list.length) throw new Error("No word list loaded");
					WORDS[wordLen] = list; // ensure populated
					VALID[wordLen] = list; // ensure populated

					target = restoreCurrent() || (await pickTarget(wordLen));
					buildBoard();
					buildKeyboard();
					localStorage.setItem(`wg-current-${wordLen}`, target);
					setStatus(`Guess the ${wordLen}-letter word ‚Ä¢ Attempts: ${maxRows}.\nGood luck!`);
					updateStats();
					syncPull(); // This now handles the check internally
					addEventListener("resize", updateLayout);
					document.getElementById("statsPanel")?.addEventListener("toggle", updateLayout);
				} catch (e) {
					console.error(e);
					setStatus("Init failed. Check that ./words files exist.");
				}
			}
			init();
		</script>
	</body>
</html>
